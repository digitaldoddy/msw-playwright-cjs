import { invariant } from "outvariant";
import { RequestHandler, SetupApi, WebSocketHandler, getResponse } from "msw";
import { CancelableCloseEvent, CancelableMessageEvent } from "@mswjs/interceptors/WebSocket";

//#region src/index.ts
/**
* Creates a fixture that controls the network in your tests.
*
* @note The returned fixture already has the `auto` option set to `true`.
*
* **Usage**
* ```ts
* import { test as testBase } from '@playwright/test'
* import { createNetworkFixture, type WorkerFixture } from '@msw/playwright'
*
* interface Fixtures {
*  network: WorkerFixture
* }
*
* export const test = testBase.extend<Fixtures>({
*   network: createNetworkFixture()
* })
* ```
*/
function createNetworkFixture(args) {
	return [async ({ page }, use) => {
		const worker = new NetworkFixture({
			page,
			initialHandlers: args?.initialHandlers || []
		});
		await worker.start();
		await use(worker);
		await worker.stop();
	}, { auto: true }];
}
var NetworkFixture = class extends SetupApi {
	#page;
	constructor(args) {
		super(...args.initialHandlers);
		this.#page = args.page;
	}
	async start() {
		await this.#page.route(/.+/, async (route, request) => {
			const fetchRequest = new Request(request.url(), {
				method: request.method(),
				headers: new Headers(await request.allHeaders()),
				body: request.postDataBuffer()
			});
			const response = await getResponse(this.handlersController.currentHandlers().filter((handler) => {
				return handler instanceof RequestHandler;
			}), fetchRequest, { baseUrl: this.getPageUrl() });
			if (response) {
				if (response.status === 0) {
					route.abort();
					return;
				}
				route.fulfill({
					status: response.status,
					headers: Object.fromEntries(response.headers),
					body: response.body ? Buffer.from(await response.arrayBuffer()) : void 0
				});
				return;
			}
			route.continue();
		});
		await this.#page.routeWebSocket(/.+/, async (ws) => {
			const allWebSocketHandlers = this.handlersController.currentHandlers().filter((handler) => {
				return handler instanceof WebSocketHandler;
			});
			if (allWebSocketHandlers.length === 0) {
				ws.connectToServer();
				return;
			}
			const client = new PlaywrightWebSocketClientConnection(ws);
			const server = new PlaywrightWebSocketServerConnection(ws);
			for (const handler of allWebSocketHandlers) await handler.run({
				client,
				server,
				info: { protocols: [] }
			}, { baseUrl: this.getPageUrl() });
		});
	}
	async stop() {
		super.dispose();
		await this.#page.unroute(/.+/);
	}
	getPageUrl() {
		const url = this.#page.url();
		return url !== "about:blank" ? url : void 0;
	}
};
var PlaywrightWebSocketClientConnection = class {
	id;
	url;
	constructor(ws) {
		this.ws = ws;
		this.id = crypto.randomUUID();
		this.url = new URL(ws.url());
	}
	send(data) {
		if (data instanceof Blob) {
			/**
			* @note Playwright does not support sending Blob data.
			* Read the blob as buffer, then send the buffer instead.
			*/
			data.bytes().then((bytes) => {
				this.ws.send(Buffer.from(bytes));
			});
			return;
		}
		if (typeof data === "string") {
			this.ws.send(data);
			return;
		}
		this.ws.send(
			/**
			* @note Forcefully cast all data to Buffer because Playwright
			* has trouble digesting ArrayBuffer and Blob directly.
			*/
			Buffer.from(
				/**
				* @note Playwright type definitions are tailored to Node.js
				* while MSW describes all data types that can be sent over
				* the WebSocket protocol, like ArrayBuffer and Blob.
				*/
				data
			)
		);
	}
	close(code, reason) {
		const resolvedCode = code ?? 1e3;
		this.ws.close({
			code: resolvedCode,
			reason
		});
	}
	addEventListener(type, listener, options) {
		/**
		* @note Playwright does not expose the actual WebSocket reference.
		*/
		const target = {};
		switch (type) {
			case "message": {
				this.ws.onMessage((data) => {
					listener.call(target, new CancelableMessageEvent("message", { data }));
				});
				break;
			}
			case "close": {
				this.ws.onClose((code, reason) => {
					listener.call(target, new CancelableCloseEvent("close", {
						code,
						reason
					}));
				});
				break;
			}
		}
	}
	removeEventListener(event, listener, options) {
		console.warn("@msw/playwright: WebSocketRoute does not support removing event listeners");
	}
};
var PlaywrightWebSocketServerConnection = class {
	#server;
	#bufferedEvents;
	#bufferedData;
	constructor(ws) {
		this.ws = ws;
		this.#bufferedEvents = [];
		this.#bufferedData = [];
	}
	connect() {
		this.#server = this.ws.connectToServer();
		/**
		* @note Playwright does not support event buffering.
		* Manually add event listeners that might have been registered
		* before `connect()` was called.
		*/
		for (const [type, listener, options] of this.#bufferedEvents) this.addEventListener(type, listener, options);
		this.#bufferedEvents.length = 0;
		for (const data of this.#bufferedData) this.send(data);
		this.#bufferedData.length = 0;
	}
	send(data) {
		if (this.#server == null) {
			this.#bufferedData.push(data);
			return;
		}
		this.#server.send(data);
	}
	close(code, reason) {
		invariant(this.#server, "Failed to close connection to the actual WebSocket server: connection not established. Did you forget to call `connect()`?");
		this.#server.close({
			code,
			reason
		});
	}
	addEventListener(type, listener, options) {
		if (this.#server == null) {
			this.#bufferedEvents.push([
				type,
				listener,
				options
			]);
			return;
		}
		const target = {};
		switch (type) {
			case "message": {
				this.#server.onMessage((data) => {
					listener.call(target, new CancelableMessageEvent("message", { data }));
				});
				break;
			}
			case "close": {
				this.#server.onClose((code, reason) => {
					listener.call(target, new CancelableCloseEvent("close", {
						code,
						reason
					}));
				});
				break;
			}
		}
	}
	removeEventListener(type, listener, options) {
		console.warn("@msw/playwright: WebSocketRoute does not support removing event listeners");
	}
};

//#endregion
export { NetworkFixture, createNetworkFixture };